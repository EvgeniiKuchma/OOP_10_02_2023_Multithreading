#include <iostream>
#include <thread>
#include <chrono>

void work(int x , int y){
std::cout << " Work started!" << std::endl;
std::this_thread::sleep_for(std::chrono::milliseconds(3000));
std::cout << " Work thread: " <<std::this_thread::get_id() << std::endl;
std::cout << " Work ended!" << std::endl;
}
int main() {
	setlocale(LC_ALL, "Russian");////////////////////////

	//параллелизм(Parallelism) и конкурентность(Concurrency)
	//main tread главный  поток на котором выполняется ваша пррограмма. порождает другие потоки , после завршения выполнеия потоками команды его необходимо за join нить
	//операционная система определяет количествьоим выделяемой вам памяти и управляет потоками при выролнении вашей программой
	//распараллелить программу это значит разделить ее выполнение между потоками(Parallelism)
	//(Concurerency) - можтет переключатся между потоками при выполнении задач(1 задача на Т2, 2я на T3) - 
	//когда несколько потоков дконкуриируют за вычислительную мощность ядра и в этот момент конкурируют
	//хорошей практикой является не блокировка главного потока
	//std::cout - non thread safe - не потоко безопасный вывод 
	
	std::cout << " Main thread: " << std::this_thread::get_id() << std::endl;
	std::thread T1(work, 5, 6);//функция всегда пердается в параметры по указателю, создание потока Т1
	std::this_thread::sleep_for(std::chrono::milliseconds(4000));
	std::cout << " Hello!" << std::endl;
	
	T1.join();//обязательно необходимо подключить поток в последствии присоединяем t1 к главному потоку
	 //главный поток не остановится пока к нему не присоединится другой поток
	
	//Лямбда функция в отдельном потоке
	//std::thread T1([](int a , int d){ вся запись это указатель на функцию
	//std::cout << " Work started!" << std::endl;
	//std::this_thread::sleep_for(std::chrono::milliseconds(3000));
	//std::cout << " Work thread: " <<std::this_thread::get_id() << std::endl;
	//std::cout << " Work ended!" << std::endl;
	//}, 5, 6);//аргументы закидываемые в лямбда функцию
	
	std::thread T2(work, 23,3);
	std::cout << " 2 worh tread " << std::endl;
	std::thread T3(work, 4,5);
	std::cout << " 3 worh tread " << std::endl;
	T2.join();
	T3.join();
	//нельзя гарантировать порядок выполнения потоков( предугадать) порядок выполнения потоков  - главная проблема выполнения на многопоточном коде 
	//мьючиал эксклюзив -  взаимо исключающий доступ
	//race condition - "гонка данных"
	//ини стотит из заголовков ключ значение 
	//погуглить что такое ини файлы
	//1.Найти в каком заголовке лежить ключ х
	//2. существует ли заголовок х
	//3.сущ. ли ключ в заголовке х
	//4.какое значение у ключа   в заголовке х
	//не читать комментарии но не читать секции . общее название настройки 
	//заголовок ини файла в квадратных скобках а под заголовком ключ и значение, между секциями и  ключом значение могут быть различные знаки
	return 0;
}